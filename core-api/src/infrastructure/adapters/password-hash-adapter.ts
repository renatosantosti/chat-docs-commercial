import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { injectable, singleton } from 'tsyringe';
import IPasswordHashAdapter from 'application/interfaces/adapters/password-hashing';
import { authConfig } from 'config';

/**
 * @description PasswordHashAdapter class
 * @implements IPasswordHashAdapter
 * @injectable singleton
 */
@injectable()
@singleton()
export default class PasswordHashAdapter implements IPasswordHashAdapter {
  /***
   * @description Generate a new hash 
   */
  async createHash(password: string): Promise<string> {
    return await bcrypt.hash(password, authConfig.saltRounds);
  }

  /**
   * @description validate hash code if the target hash is valid with the source hash
   * @param textPlain 
   * @param hashCode 
   * @returns Promise<boolean>
   */
  async validateHash(textPlain: string, hashCode: string): Promise<boolean> {
    return await bcrypt.compare(textPlain, hashCode);
  }

  /**
   * @description create a new token 
   * @param source 
   * @returns boolean
   */
  createToken<T>(source: T): string {

    const token = jwt.sign(source as object, authConfig.secret, {
      expiresIn: authConfig.expires as any,  
    });

    return token;
  };

  /**
 * @description validate token if it was generated by secret
 * @param hashSource 
 * @param hashTarget 
 * @returns string | any
 */
  validateToken(token: string, secret: string): string | any {
    return jwt.verify(token, secret);
  }

  /**
 * @description decode a token
 * @param hashSource 
 * @returns string | null
 */
  decodeToken(token: string): string | any {
    return jwt.decode(token);
  }
}
